[{:ed2 {:label "Uncomplicate", :opts {:order :row, :eltsper 1, :size "auto", :wrapfn {:tid :ed2, :$split nil, :fn [quote editor-repl-tab], :layout :left-right, :ns doc.code, :ed-out-order :first-last, :width "730px", :src "(System/getenv \"LD_LIBRARY_PATH\")\n\n;;; All of this is must run on the JVM.  So, use Ctrl-X J (with cursor at\n;;; end right paren) or Ctrl-X Ctrl-J with curso inside a form\n\n;;; Dependencies and resource requires and imports\n;;;\n(deps '[[uncomplicate/neanderthal \"0.26.1\"]\n        [criterium \"0.4.4\"]])\n\n(require '[uncomplicate.commons.core\n           :refer [with-release let-release\n                   Releaseable release]]\n         '[uncomplicate.fluokitten.core :refer [fmap!]]\n         '[uncomplicate.neanderthal\n           [native :refer [dv dge]]\n           [core :refer [mv! mv axpy! scal! transfer!]]\n           [math :refer [signum exp]]\n           [vect-math :refer [fmax! tanh! linear-frac!]]])\n\n(import clojure.lang.IFn)\n\n\n\n;;; Code examples\n;;;\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               h1 (dv 4)]\n   (print-str(mv! w1 x h1)))\n\n\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               h1 (dv 4)\n               w2 (dge 1 4 [0.75 0.15 0.22 0.33])\n               y (dv 1)]\n  (print-str (mv! w2 (mv! w1 x h1) y)))\n\n\n(defn step! [threshold x]\n  (fmap! signum (axpy! -1.0 threshold (fmax! threshold x x))))\n\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               threshold (dv 0.7 0.2 1.1 2)]\n  (print-str (step! threshold (mv w1 x))))\n\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias (dv 0.7 0.2 1.1 2)\n               zero (dv 4)]\n  (print-str(step! zero (axpy! -1.0 bias (mv w1 x)))))\n;;; bias is same as threshold. No need for extra zero vector\n;;; ==\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias (dv 0.7 0.2 1.1 2)]\n  (print-str (step! bias (mv w1 x))))\n\n\n;;; Activation Functions\n\n(defn relu! [threshold x]\n  (axpy! -1.0 threshold (fmax! threshold x x)))\n\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias (dv 0.7 0.2 1.1 2)]\n  (print-str (relu! bias (mv w1 x))))\n\n;;; tanh is directly available in vect-math\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias (dv 0.7 0.2 1.1 2)]\n  (print-str (tanh! (axpy! -1.0 bias (mv w1 x)))))\n\n;;; sigmoid S(x) = 1/2 + (1/2 * tanh(x/2))\n(defn sigmoid! [x]\n  (linear-frac! 0.5 (tanh! (scal! 0.5 x)) 0.5))\n\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias (dv 0.7 0.2 1.1 2)]\n  (print-str (sigmoid! (axpy! -1.0 bias (mv w1 x)))))\n\n\n;;; Manually stacking with tanh and sigmoid\n(with-release [x (dv 0.3 0.9)\n               w1 (dge 4 2 [0.3 0.6\n                            0.1 2.0\n                            0.9 3.7\n                            0.0 1.0]\n                       {:layout :row})\n               bias1 (dv 0.7 0.2 1.1 2)\n               h1 (dv 4)\n               w2 (dge 1 4 [0.75 0.15 0.22 0.33])\n               bias2 (dv 0.3)\n               y (dv 1)]\n  (tanh! (axpy! -1.0 bias1 (mv! w1 x h1)))\n  (print-str (sigmoid! (axpy! -1.0 bias2 (mv! w2 h1 y)))))\n\n\n\n\n;;; ======================================================================= ;;;\n;;;                    Part 3 - automate stacking.\n;;; ======================================================================= ;;;\n\n(defprotocol Parameters\n  (weights [this])\n  (bias [this]))\n\n;;; Implements release method of Releasable protocol and the invoke\n;;; method of IFn. Includes parameters `w' weights `b' biases\n(deftype FullyConnectedInference [w b h activ-fn]\n  Releaseable\n  (release [_]\n    (release w)\n    (release b)\n    (release h))\n  Parameters\n  (weights [this] w)\n  (bias [this] b)\n  IFn\n  (invoke [_ x]\n    (activ-fn b (mv! w x h))))\n\n;;; Constructor for inference layer\n(defn fully-connected [activ-fn in-dim out-dim]\n  (let-release [w (dge out-dim in-dim)\n                bias (dv out-dim)\n                h (dv out-dim)]\n    (->FullyConnectedInference w bias h activ-fn)))\n\n\n;;; Bias versions of sigmoid and tanh\n(defn activ-sigmoid! [bias x]\n  (axpy! -1.0 bias x)\n  (linear-frac! 0.5 (tanh! (scal! 0.5 x)) 0.5))\n\n(defn activ-tanh! [bias x]\n  (tanh! (axpy! -1.0 bias x)))\n", :out-height "700px", :eid "ed-ed2", :height "700px"}}, :specs []}} {:kixs {:label "Kixistats", :opts {:order :row, :eltsper 1, :size "auto", :wrapfn {:tid :kixs, :$split nil, :fn [quote editor-repl-tab], :layout :left-right, :ns doc.code, :ed-out-order :first-last, :width "730px", :src ";;; All of this is must run on the JVM.  So, use Ctrl-X J (with cursor at\n;;; end right paren) or Ctrl-X Ctrl-J with curso inside a form\n\n(deps '[[kixi/stats \"0.5.2\"]])\n\n(require '[kixi.stats.core\n           :as ks\n           :refer [mean median standard-deviation correlation]]\n         '[kixi.stats.distribution :as kd]\n         '[redux.core :refer [fuse]])\n\n(->> [{:x 2} {:x 4} {:x 4} {:x 4} {:x 5} {:x 5} {:x 5} {:x 7} {:x 9}]\n     (transduce (map :x) standard-deviation))\n\n(->>  [{:x 1 :y 3} {:x 2 :y 2} {:x 3 :y 1}]\n      (transduce identity (correlation :x :y)))\n\n(->> [{:x 1 :y 3 :z 2} {:x 2 :y 2 :z 4} {:x 3 :y 1 :z 6}]\n     (transduce identity (ks/correlation-matrix {:x :x :y :y :z :z})))\n\n(->> [2 4 4 4 5 5 5 7 9]\n     (transduce identity (fuse {:mean mean :sd standard-deviation})))\n\n;;; Calculate the median only of numbers greater than 5:\n(def gt5? (filter #(> % 5)))\n(transduce gt5? median (range 10))\n\n;; Count both all numbers and those greater than 5:\n(transduce identity (fuse {:n ks/count :gt5 (gt5? ks/count)}) (range 10))\n\n;; Calculate the median, iqr and 5-number summary:\n(->> (range 100)\n     (transduce identity (fuse {:median median\n                                :iqr ks/iqr\n                                :summary ks/summary})))\n\n;; Calculate the 2.5 and 97.5 quantile from an empirical distribution\n(def distribution\n  (->> (range 100)\n    (transduce identity ks/histogram)))\n\n{:lower (kd/quantile distribution 0.025)\n :upper (kd/quantile distribution 0.975)}\n\n\n;;; The post-complete function defined in the kixi.stats.core allows us to\n;;; chain the histogram and quantile steps like so:\n;;;\n;;; Calculate the 2.5 and 97.5 quantile from an empirical disribution\n\n(->> (range 100)\n     (transduce identity (ks/post-complete ks/histogram\n                           (fn [hist]\n                             {:lower (kd/quantile hist 0.025)\n                              :upper (kd/quantile hist 0.975)}))))\n\n\n\n\n;;; Distribution sampling\n;;;\n;;; kixi.stats.distribution contains functions for specifying and sampling from\n;;; statistical distributions.\n\n(kd/draw (kd/binomial {:n 100 :p 0.5}))\n(kd/sample 10 (kd/binomial {:n 100 :p 0.5}))\n\n\n\n\n;;; Discrete summarisation\n;;;\n;;; The Bernoulli, binomial and categorical distributions are discrete, so\n;;; samples can be summarised by counting the number of times each variate \n;;; appears. Discrete distributions can be directly sampled in this way with \n;;; sample-summary:\n\n(require '[kixi.stats.distribution :refer [sample-summary bernoulli]])\n\n(kd/sample-summary 1000 (kd/bernoulli {:p 0.3}))\n(kd/sample-summary 1000 (kd/binomial {:n 100 :p 0.5}))\n\n;;; Visualize in a new tab.  Use Ctrl-X Ctrl-C here. It will run the data\n;;; computation on the server and then pass to client visualizer hmi/sv!\n(->\n (hc/xform\n  ht/bar-chart :TID :ksvis\n  :DATA (clj (mapv (fn[[x y]] {:x x :y y})\n                   (kd/sample-summary 1000 (kd/binomial {:n 100 :p 0.5})))))\n hmi/sv!)\n\n\n\n\n;;; Deterministic sampling\n;;;\n;;; The sampling functions draw, sample and sample-summary are all designed to \n;;; perform deterministically when provided with a seed value. If repeatable \n;;; samples are desired, pass {:seed SEED_LONG} as the final argument:\n\n(require '[kixi.stats.distribution :refer [uniform]])\n\n(kd/draw (kd/uniform {:a 0 :b 1}) {:seed 42})\n(kd/draw (kd/uniform {:a 0 :b 1}) {:seed 42})\n(kd/draw (kd/uniform {:a 0 :b 1}))\n\n\n\n\n;;; Statistical tests\n;;;\n;;; The kixi.stats.test namespace contains functions for performing statistical\n;;; tests.\n;;;\n;;; For example, we can perform a z-test between a known population mean & \n;;; standard deviation and a sampled mean with a given sample size in the \n;;; following way:\n(require '[kixi.stats.test :as kt])\n\n(kt/p-value (kt/simple-z-test {:mu 100 :sd 12} {:mean 96 :n 55}))\n(kt/p-value (kt/simple-z-test {:mu 100 :sd 12} {:mean 96 :n 55}) :<>)\n(kt/p-value (kt/simple-z-test {:mu 100 :sd 12} {:mean 96 :n 55}) :<)\n(kt/p-value (kt/simple-z-test {:mu 100 :sd 12} {:mean 96 :n 55}) :>)\n\n;;; As with the kixi.stats.distribution namespace - which contains many \n;;; functions which mirror kixi.stats.core - simple-z-test is also available in \n;;; kixi.stats.core. The latter function returns a reducing function for use \n;;; with transduce.\n;;;\n;; If the standard deviation is not provided, the sample standard deviation \n;;; will be used instead (a 'plug-in test')\n(kt/p-value(transduce identity (ks/simple-z-test {:mu 100}) (range 200)))\n\n\n:end", :out-height "700px", :eid "ed-kixs", :height "700px"}}, :specs []}}]
